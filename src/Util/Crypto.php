<?php
/**
 * @package       johnpancoast/php-common
 * @copyright (c) 2016 John Pancoast
 * @license       MIT
 */

namespace Pancoast\Common\Util;

use Pancoast\Common\Exception\InvalidHashingAlgorithmException;
use Pancoast\Common\Exception\SystemCryptoException;
use Pancoast\Common\Util\Crypto\MessageSignature;

/**
 * Crypto utilities
 *
 * @author John Pancoast <johnpancoaster@gmail.com>
 */
class Crypto implements CryptoInterface
{
    /**
     * @var string Private key
     */
    private $privateKey;

    /**
     * How many times does the class attempt to generate cryptographically secure random bytes
     *
     * @var int
     */
    private $strongCryptoAttempts;

    /**
     * SHA256 hashing algorithm
     *
     * @var string
     * @todo Add others as needed and add to self::getHashingAlgos().
     */
    const HASH_ALGO_SHA256 = 'sha256';

    /**
     * Default strong crypto attempts
     *
     * If not specified by user, this is the default amount that this class
     * attempts to generate cryptographically strong random bytes
     *
     * @var int
     * @see self::generateSecureRandomBytes()
     * @see http://php.net/openssl_random_pseudo_bytes()
     */
    const DEFAULT_STRONG_CRYPTO_ATTEMPTS = 5;

    /**
     * Default random byte length
     *
     * If not specified by user, this is the amount of random bytes that will be generated by default.
     *
     * @var int
     */
    const DEFAULT_RANDOM_BYTE_LENGTH = 256;

    /**
     * Default hashing algorithm
     *
     * If not specified by user, this is the default hashing algo this class uses
     *
     * @var string
     */
    const DEFAULT_HASHING_ALGO = self::HASH_ALGO_SHA256;

    /**
     * Constructor
     *
     * @param string $privateKey           Private key used for crypto, message signatures
     * @param int    $strongCryptoAttempts How many times we try to create a cryptograhpically strong token.
     */
    public function __construct(
        $privateKey,
        $strongCryptoAttempts = self::DEFAULT_STRONG_CRYPTO_ATTEMPTS
    )
    {
        Validator::validateTypes([
            'string' => $privateKey,
            'int' => $strongCryptoAttempts,
        ]);

        $this->privateKey = $privateKey;
        $this->strongCryptoAttempts = $strongCryptoAttempts;
    }

    /**
     * @inheritDoc
     */
    public function generateHmac($message, $hashingAlgo = self::DEFAULT_HASHING_ALGO)
    {
        Validator::validateTypes([
            'string' => $message,
            'string' => $hashingAlgo,
        ]);

        return hash_hmac($hashingAlgo, $message, $this->privateKey);
    }

    /**
     * @inheritDoc
     */
    public function generateMessageSignature($message = null)
    {
        Validator::validateType($message, ['string', null]);

        return new MessageSignature($message ?: bin2hex($this->generateRandomBytes(16)), $this);
    }

    /**
     * @inheritDoc
     * @see self::$strongCryptoAttempts
     */
    public function generateRandomBytes($byteLength = self::DEFAULT_RANDOM_BYTE_LENGTH)
    {
        Validator::validateType($byteLength, 'int');

        $cryptoStrong = false;

        for ($i = 0; !$cryptoStrong && $i < $this->strongCryptoAttempts; $i++) {
            // TODO when php7 is common, consider using http://php.net/random_bytes instead.
            //      another option is to use https://github.com/paragonie/random_compat until PHPv7 but
            //      this call is safe for random bytes for now.
            $bytes = openssl_random_pseudo_bytes($byteLength, $cryptoStrong);
        }

        if (!$cryptoStrong) {
            throw new SystemCryptoException();
        }

        return $bytes;
    }

    /**
     * @inheritDoc
     */
    public static function getHashingAlgos()
    {
        return [
            self::HASH_ALGO_SHA256
        ];
    }
}
